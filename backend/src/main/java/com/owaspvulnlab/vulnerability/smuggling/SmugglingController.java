package com.owaspvulnlab.vulnerability.smuggling;

import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/smuggle")
@CrossOrigin(origins = "*")
public class SmugglingController {

    @PostMapping("/parse")
    public Map<String, Object> parse(@RequestBody String raw) {
        Map<String, Object> res = new HashMap<>();
        String[] lines = raw.split("\r?\n");
        int contentLength = -1;
        boolean chunked = false;
        int i = 0;
        for (; i < lines.length; i++) {
            String line = lines[i];
            if (line.isEmpty()) { i++; break; }
            String lower = line.toLowerCase();
            if (lower.startsWith("content-length:")) {
                try { contentLength = Integer.parseInt(line.split(":")[1].trim()); } catch (Exception ignored) {}
            }
            if (lower.startsWith("transfer-encoding:")) {
                if (lower.contains("chunked")) chunked = true;
            }
        }
        // 漏洞：错误优先级，始终优先使用 Content-Length
        StringBuilder body = new StringBuilder();
        int consumed = 0;
        while (i < lines.length) {
            if (chunked) {
                // 错误处理：忽略 chunked 边界，当作普通文本读取
                String line = lines[i++];
                body.append(line).append("\n");
                consumed += line.length();
                if (contentLength != -1 && consumed >= contentLength) break;
            } else {
                String line = lines[i++];
                body.append(line).append("\n");
                consumed += line.length();
                if (contentLength != -1 && consumed >= contentLength) break;
            }
        }
        res.put("contentLength", contentLength);
        res.put("chunked", chunked);
        res.put("body", body.toString());
        res.put("note", "此示例模拟错误解析，真实走私需在代理/网关层触发");
        return res;
    }
}

